# -*-perl-*-

=head1 Refactoring with Moose

Introducing Moose into a pre-
existing codebase, tips for
success and traps to watch for

Tomas Doran:

    irc: t0m
    <br />
    bobtfish@bobtfish.net
    <br />
    CPAN: BOBTFISH

=head1 You may also know me from.

G<t0m-cpan.png>

=head1 Part 1 - Refactoring

=over

=item Is not a project.

=item Does not add functionality.

=item Does not take long.

=item Needs tests (I will say this again)

=item Is something you should do as you write code.

=item Can also be retrofitted (after you write tests)

=back

=head1 Foo

    'Any fool can write code that a computer
    understands. Only a good programmer
    can write code that a human
    understands’

- Martin Fowler

=head1 bar

=over

=item *

 Moose helps me write more consise,
easier to understand code.

=item *

So just converting a class to Moose ==
refactoring, right?

=back

=head1 quux

Just converting to Moose is
refactoring

(in my book at least).


=head1 baa

Just converting to Moose is
refactoring

IF YOU HAVE TESTS


=head1 Part II - Common refactorings

=over

=item Replace constructor with factory method (BUILD)

=item Encapsulate field (attributes)

=item Change unidirectional association to bidirectional (weak => 1)

=item Hide delegate (handles)

=item Extract interface (Roles)

=item Tease apart inheritance (Roles)

=item Replace inheritance with delegation (lazy_build)

=item Replace data value with object (type coercions)

=back

=head1 Part II - Common refactorings

=over

=item Replace array with object (BUILDARGS, type coercions)

=item Duplicate observed data (handles, trigger, lazy_build)

=item Encapsulate collection (MX::AttributeHelpers)

=item Replace type code with subclass (augment)

=item Replace type code with strategy (MX::Traits)

=item Parameterize method (meta programming)

=item Remove setting method (is => ‘ro’, init_arg => undef)

=back

=head1 Part III - Moose with existing classes

=head2 Refactor gradually

=over

=item From the top down..

=item Or the bottom up

=back

=head2 You need tests

=head1 Not inheriting a Moose::Object constructor (at all)

=head2 You lose:

=over

=item BUILD

=item default

=item builder

=back

=head1 Can still use:

=over

=item lazy_build

=item Roles

=item Method modifiers

=back

=head1 Not inheriting a Moose::Object destructor

Your own DESTROY method works just
like usual, no DEMOLISH

=head1 Don't go mad!

=over

=item 1. Convert several independent parts of the same class hierarchy.

=item 2. Use different combinations of MooseX modules

=item 3. Write 3 of your own Moose::Exporter based things.

=back

=head2 BANG. This will hurt you with metaclass incompatibility

=head1 Beware global destruction

Moving stuff onto the metaclass and delegating in DEMOLISH methods (especially using handles
and/or MooseX::ClassAttribute) will hurt you.
Moose with existing classes


This is not really the fault of Moose, it’s due to the
way global destruction works.

=over

=item KISS

=item Did I mention tests?

=back

=head1 Summary

=head2 KISS

=head2 Write better code

=head2 Write less code

=head2 Write more tests

